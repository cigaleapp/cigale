name: Developer deployments

permissions: 
  actions: read
  contents: read

env:
  HOST: gwen.works

on:
  workflow_call: 
    secrets:
      DEV_DEPLOYMENTS_SSH_PRIVATE_KEY:
        required: true
      DEV_DEPLOYMENTS_HOST_KEY:
        required: true
    inputs:
      environment:
        type: string
        description: Name of the Github Environment
      environment-url-append:
        type: string
        description: Suffix to append to the environment URL
        default: ''
      domain: 
        type: string
        description: You shouldnt have to change this
        # TODO: once have cigale.cnrs.fr, change it
        default: cigale.gwen.works
      subdomain: 
        type: string
        description: Subdomain of the dev deployments domain to upload to
        required: true
      artifact:
        type: string
        description: Name of artifact to upload to the subdomain
        required: true
      path: 
        type: string
        description: Path to put the contents at
        required: true
      live-check:
        type: boolean
        default: true
        description: Inject a commit hash comment in index.html, and wait for it to be live

jobs:
  upload:
    runs-on: ubuntu-latest
    # Ugly in Github list of environments cuz it causes text wrapping
    # name: Deploy to ${{ inputs.subdomain }}.${{ inputs.domain }}${{ inputs.path }}
    name: Deploy
    environment: 
      name: ${{ inputs.environment }}
      url: https://${{ inputs.subdomain }}.${{ inputs.domain }}${{ inputs.path }}${{ inputs.environment-url-append }}
    steps:
      - name: Get the archive
        uses: actions/download-artifact@v7
        with:
          name: ${{ inputs.artifact }}
          path: to-upload

      - name: Inject live-check comment
        if: inputs.live-check
        run: |
          cat <<EOF >> to-upload/index.html
          <!-- COMMIT: ${{ github.sha }} -->
          EOF

          echo Injected live-check comment into to-upload/index.html:
          tail -n 3 to-upload/index.html
      - name: Create SSH identity
        env: 
          PRIVATE_KEY: ${{ secrets.DEV_DEPLOYMENTS_SSH_PRIVATE_KEY }}
          USERNAME: cigale
          HOST_KEY: ${{ secrets.DEV_DEPLOYMENTS_HOST_KEY }}
        run: |
          key=~/.ssh/dev-deployments-key

          echo Recreating keypair from private key...
          mkdir -p $(dirname $key)
          echo "$PRIVATE_KEY" > $key
          chmod 600 $key
          ssh-keygen -f $key -y > $key.pub
          echo Public key is $(cat $key.pub)

          cat <<EOF > ~/.ssh/config
            Host dev-deployments
              HostName $HOST
              User $USERNAME
              IdentityFile $key
          EOF
          echo Wrote config file: $(cat ~/.ssh/config)

          echo Adding server host key to known_hosts...
          echo "$HOST $HOST_KEY" >> ~/.ssh/known_hosts

          echo Setting up SSH connection to server...
          ssh -vT dev-deployments "echo OK"
      - name: Transfer to server over SSH
        run: |
          set -x
          path="www/${{ inputs.subdomain }}${{ inputs.path }}"

          # Clean directory
          ssh dev-deployments "rm -rf $path"
          ssh dev-deployments "mkdir -p $path"

          # Upload
          rsync -avz --delete --progress to-upload/ "dev-deployments:$path"

      - name: Wait for it to be live
        if: inputs.live-check
        env: 
          URL: https://${{ inputs.subdomain }}.${{ inputs.domain }}${{ inputs.path }}
        run: | 
          echo Getting server IP from $HOST
          resolved_ip=$(dig +short $HOST | head -n 1)
          echo Resolved IP is $resolved_ip

          dns="--resolve ${{ inputs.subdomain }}.${{ inputs.domain }}:443:$resolved_ip"
          echo Using curl with $dns

          string="<!-- COMMIT: ${{ github.sha }} -->"

          echo "Checking if '$string' is in reponse at $URL"
          touch index.html
          curl -fsSL $dns $URL > index.html 
          while ! grep -F "$string" index.html; do
            echo "Deployment not live yet, waiting..."
            sleep 5
            rm index.html
            touch index.html
            curl -fsSL $dns $URL > index.html
          done


        
