const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./Don2Ydo1.js","./BwdvgNQo.js","./DIeogL5L.js","./BAHerLWL.js","./PPVm8Dsz.js"])))=>i.map(i=>d[i]);
import{_}from"./PPVm8Dsz.js";import{L,N as P,m as R,O as E,G as S,a as z,C as J,P as b,Q as k,n as h,S as x,R as H,T as M,A as K,U as C,V as D,W as G}from"./Don2Ydo1.js";function A(e){return JSON.stringify(e instanceof Date&&P(e)?L(e,"yyyy-MM-dd'T'HH:mm:ss"):e)}function Q({value:e,...n}){return{...n,value:A(e)}}function X(e){return R(e,Q)}async function U({db:e,metadataId:n,confidence:a,value:f,alternatives:m}){const s=Array.isArray(m)?m:Object.entries(m).map(([i,r])=>({value:JSON.parse(i),confidence:r}));return await Promise.all([{value:f,confidence:a},...s].map(async({confidence:i,value:r})=>{const c=await e.get("MetadataOption",E(n,r));if(!c?.cascade)return;const{cascade:t}=c;return{cascade:t,confidence:i}})).then(i=>{const r=S(i.filter(z).flatMap(({cascade:t,confidence:o})=>J(t).map(([g,l])=>({optionId:E(g,l),confidence:o}))),t=>t.optionId,t=>t.confidence);return[...S(r.entries(),([t])=>k(t).metadataId,([t,o])=>({value:k(t).key,confidence:b(o)})).entries()].map(([t,o])=>{const[{value:g,confidence:l},...w]=o.toSorted(({confidence:p},{confidence:O})=>O-p);return{metadataId:t,value:g,confidence:l,alternatives:w}})})}async function Y({cache:e,protocolId:n,option:a,db:f}){if(!n)return{};if(!a)return{};if(a.key in e)return e[a.key];async function m(s,i,r,c=0){const t={};for(const[o,g]of Object.entries(i??{})){if(r.has(o))continue;r.add(o);const l=await f.get("Metadata",h(s,o)).then(w=>x.Metadata.assert(w));if(l)if(l.type==="enum"){const w=await f.get("MetadataOption",E(h(s,l.id),g));if(!w)continue;t[l.id]={value:w.label,metadata:l.label,depth:c,...H(w,"color","icon")},Object.keys(w.cascade??{}).length>0&&await m(s,w.cascade??{},r,c+1).then(p=>{Object.assign(t,p)})}else t[l.id]={value:g,metadata:l.label,depth:c}}return t}return e[a.key]=await m(n,a.cascade??{},new Set),Object.keys(e).length>4e3&&(console.debug("Halving cascadeLabels cache"),e=Object.fromEntries(Object.entries(e).slice(2e3))),e[a.key]}function Z(e,n){if(n){const a=D(n,e);return IDBKeyRange.bound(a+":",a+":￿")}else return IDBKeyRange.bound(h("",e),h("￿",e))}async function N(e,...n){try{const a=await _(()=>import("./Don2Ydo1.js").then(f=>f.a$),__vite__mapDeps([0,1,2,3,4]),import.meta.url);await Promise.all(n.map(f=>a.tables[f].refresh(e)))}catch(a){console.warn(`Cannot refresh tables ${n}:`,a)}}async function F({db:e,subjectId:n,metadataId:a,type:f,value:m,confidence:s=1,confirmed:i=!1,alternatives:r=[],manuallyModified:c=!1,clearErrors:t=!0,isDefault:o=!1,cascadedFrom:g=[],sessionId:l,abortSignal:w}){if(!C(a))throw new Error(`Le metadataId ${a} n'est pas namespacé`);s>1&&(console.warn(`Confidence ${s} is greater than 1, capping to 1`),s=1),w?.throwIfAborted();const p={value:A(m),confidence:s,confirmed:i,manuallyModified:c,isDefault:o,alternatives:Array.isArray(r)?Object.fromEntries(r.map(({value:u,confidence:v})=>(v>1&&(console.warn(`Confidence ${v} of alternative ${u} is greater than 1, capping to 1`),v=1),[A(u),v]))):r};p.alternatives=Object.fromEntries(Object.entries(p.alternatives).filter(([u])=>u!==p.value)),console.debug(`Store metadata ${a} = `,m,` in ${n}`,p);const O=await e.get("Metadata",a);if(!O)throw new Error(`Métadonnée inconnue avec l'ID ${a}`);if(f&&O.type!==f)throw new Error(`Type de métadonnée incorrect: ${O.type} !== ${f}`);w?.throwIfAborted();const y=await e.get("Image",n),$=await e.get("Observation",n),d=await e.get("Session",n),V=await e.getAll("Image").then(u=>u.filter(({fileId:v})=>v===n));if(w?.throwIfAborted(),d)d.metadata?d.metadata[a]=p:d.metadata={[a]:p},e.put("Session",d);else if(y)y.metadata[a]=p,t&&y.metadataErrors?.[a]&&delete y.metadataErrors[a],e.put("Image",y);else if($)$.metadataOverrides[a]=p,t&&$.metadataErrors?.[a]&&delete $.metadataErrors[a],e.put("Observation",$);else if(V.length>0)for(const{id:u}of V)await F({db:e,sessionId:l,subjectId:u,metadataId:a,value:m,confidence:s,isDefault:o,confirmed:i,manuallyModified:c,clearErrors:t,abortSignal:w});else throw new Error(`Aucune image ou observation avec l'ID ${n}`);w?.throwIfAborted();const T=await U({db:e,metadataId:a,value:m,confidence:s,alternatives:r});for(const u of T){if(w?.throwIfAborted(),g.includes(u.metadataId))throw new Error(`Boucle infinie de cascade détectée pour ${u.metadataId} avec ${u.value}: ${g.join(" -> ")} -> ${a} -> ${u.metadataId}`);console.info(`Cascading metadata ${a} @ ${m} -> ${u.metadataId}  = ${u.value}`);const v=C(a);if(!v)throw new Error(`Metadata ${a} is not namespaced, cannot cascade onto ${u.metadataId}`);u.metadataId=D(u.metadataId,v),await F({db:e,sessionId:l,subjectId:n,manuallyModified:c,isDefault:o,confirmed:i,cascadedFrom:[...g,a],abortSignal:w,clearErrors:t,...u})}g.length===0&&l&&await N(l,d?"Session":y?"Image":"Observation")}async function W({db:e,subjectId:n,sessionId:a,metadataId:f},...m){const s=await e.get("Image",n),i=await e.get("Observation",n),r=await e.getAllFromIndex("Image","sessionId",a).then(t=>t.filter(({fileId:o})=>o===n));if(!s&&!i&&r.length===0)throw new Error(`Aucune image ou observation avec l'ID ${n}`);const c=m.map(t=>{try{JSON.stringify(t.details)}catch{t.details=`{{Non-JSONable}} ${String(t.details)}`}return G.assert(t)});if(console.debug(`Store metadata error on ${f} in ${n}:`,m),s)s.metadataErrors??={},s.metadataErrors[f]=c,e.put("Image",s);else if(i)i.metadataErrors??={},i.metadataErrors[f]=c,e.put("Observation",i);else if(r)for(const{id:t}of r)await W({db:e,sessionId:a,subjectId:t,metadataId:f},...m)}async function B({db:e,subjectId:n,metadataId:a,recursive:f=!1,reactive:m=!0,sessionId:s}){const i=await e.get("Image",n),r=await e.get("Observation",n),c=await e.get("Session",n),t=await e.getAllFromIndex("Image","sessionId",s).then(g=>g.filter(({fileId:l})=>l===n));if(!i&&!r&&!c&&t.length===0)throw new Error(`Aucune image, observation ou session avec l'ID ${n}`);let o;if(console.debug(`Delete metadata ${a} in ${n}`),i)o=M(structuredClone(i.metadata[a])),delete i.metadata[a],e.put("Image",i);else if(c)o=M(structuredClone(c.metadata[a])),delete c.metadata[a],e.put("Session",c);else if(r){if(o=M(structuredClone(r.metadataOverrides[a])),delete r.metadataOverrides[a],e.put("Observation",r),f)for(const g of r.images)await B({db:e,sessionId:s,subjectId:g,recursive:!1,metadataId:a,reactive:!1})}else if(t)for(const{id:g}of t)await B({db:e,sessionId:s,subjectId:g,recursive:!1,metadataId:a,reactive:!1});!(o instanceof K)&&typeof o?.value=="string"&&await e.get("Metadata",a).then(l=>l?.type)==="file"&&await e.delete("MetadataValueFile",o.value),m&&s&&await N(s,"Image","Observation","Session")}export{F as a,A as b,Y as c,B as d,W as e,X as f,Z as m,Q as s};
