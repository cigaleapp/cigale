import{m as b,h as d,a as g}from"./Don2Ydo1.js";import{s as l}from"./BeqcFVE5.js";const j=new Set(["boolean","integer","float","date","location","boundingbox","enum"]);function S({definitions:a,images:o,observations:m}){const r=f(o.map(t=>t.metadata),{definitions:a}),n=f(m.map(t=>t.metadataOverrides),{definitions:a}),e=new Set([...Object.keys(r),...Object.keys(n)]),c={};for(const t of e){const s=n[t]??r[t];s&&(c[t]=s)}return c}function f(a,{definitions:o,options:m={}}){if(a.length===1)return b(a[0],e=>({...e,merged:!1}));const r={},n=new Set(a.flatMap(e=>Object.keys(e)));for(const e of n){const c=o.find(i=>i.id===e);if(!c){console.warn(`Cannot merge metadata values for unknown key ${e}`);continue}const t=a.flatMap(i=>Object.entries(i).filter(([u])=>u===e).map(([,u])=>u)),s=w(c,t,m[e]??[]);s!=null&&(r[e]={...s,merged:new Set(t.map(i=>JSON.stringify(i.value))).size>1})}return r}function w(a,o,m=[]){const r=(e,c)=>Object.fromEntries(c.flatMap(t=>Object.keys(t.alternatives)).map(t=>[t,e(c.flatMap(s=>s.alternatives[t]??null).filter(Boolean))])),n=({value:e,confidences:c})=>({value:e,manuallyModified:o.some(t=>t.manuallyModified),confidence:c(o.map(t=>t.confidence)),confirmed:o.every(t=>t.confirmed),alternatives:r(c,o)});switch(a.mergeMethod){case"average":return n({confidences:d,value:p({aggregate:d,type:a.type,values:o.map(e=>e.value),options:m})});case"max":case"min":return n({confidences:h,value:x(a.type,o,a.mergeMethod==="max"?h:O)});case"median":return n({confidences:M,value:p({aggregate:M,type:a.type,values:o.map(e=>e.value),options:m})});case"union":return n({confidences:d,value:k(a.type,o.map(e=>e.value))});case"none":return null}}function x(a,o,m){const r=Math.max(...o.map(e=>e.confidence)),n=o.filter(e=>e.confidence===r);try{return m(n.map(e=>e.value))}catch(e){return console.error(e),n[0].value}}function p({type:a,values:o,options:m,aggregate:r}){return l(a,o,{boolean:(...n)=>r(y("boolean",n))>.5,integer:(...n)=>Math.ceil(r(n)),float:(...n)=>r(n),date:(...n)=>new Date(r(y("date",n))),location:(...n)=>({latitude:r(n.map(e=>e.latitude)),longitude:r(n.map(e=>e.longitude))}),enum:(...n)=>{const e=Math.round(r(n.map(c=>m.find(t=>t.key===c)?.index).filter(g)));return m.find(c=>c.index===e)?.key??n[0]}},()=>{throw new Error(`Impossible de fusionner des valeurs de type ${a}`)})}function k(a,o){return l(a,o,{boundingbox:(...m)=>{const r=Math.min(...m.map(t=>t.x)),n=Math.min(...m.map(t=>t.y)),e=Math.max(...m.map(t=>t.x+t.w)),c=Math.max(...m.map(t=>t.y+t.h));return{x:r,y:n,w:e-r,h:c-n}}},()=>{throw new Error(`Impossible de fusionner des valeurs de type ${a} par union`)})}function y(a,o){return o.map(m=>l(a,m,{integer:r=>r,float:r=>r,boolean:r=>r?1:0,date:r=>new Date(r).getTime()},()=>{throw new Error(`Impossible de convertir des valeurs de type ${a} en nombre`)}))}function M(a){const o=a.sort((r,n)=>r-n),m=Math.floor(o.length/2);return o.length%2===0?(o[m-1]+o[m])/2:o[m]}function h(a){return Math.max(...a)}function O(a){return Math.min(...a)}export{j as M,f as a,S as m};
