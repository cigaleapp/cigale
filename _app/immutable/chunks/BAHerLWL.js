let d=()=>"";function p(o,n=[],s=1){let c="";for(let t=s;t<o.length;t++){const e=o[t];typeof e=="string"?c+=e:c+=n[e]}return c}function m(o={c:[]},n){const s=o.c,c=e=>{const r=s[e];return typeof r=="string"?[r]:Array.isArray(r)?r:[d()]},t=(e,r=[])=>p(c(e),r,0);return t._=o,t.l=n,t.c=c,t.x=p,t.t=(e,r,l)=>{const f=c(r),i=[],g=[];typeof f[0]=="number"&&i.push("");for(const u of f){if(typeof u=="string"){i.push(u);continue}g.push(l?.[u])}return typeof f.at(-1)=="number"&&i.push(""),e(i,...g)},t.p=e=>s[e]??[],t}function y(o){return{get:n=>o[n],set:(n,s)=>{o[n]=s}}}const a={},b=m();function x(o,n,s,c){a[o]={load:n,catalogs:Object.fromEntries(s.map(t=>[t])),collection:c??y({})};for(const t of s)a[o].collection.set(t,b);return t=>a[o].collection.get(t)}function h(o){for(const n of Object.values(a))for(const[s,c]of Object.entries(n.catalogs))n.collection.set(s,m(c,o))}async function j(o,n=!0){const s=[],c=[];for(const t of Object.values(a))for(const e of Object.keys(t.catalogs))s.push(t.load(e,o)),c.push([e,t]);for(const[t,e]of(await Promise.all(s)).entries()){const[r,l]=c[t];l.catalogs[r]=e}n&&h(o)}export{y as d,j as l,x as r};
