import{s as f,g as h,i as d}from"./Bn_ZbADV.js";import{c as P,f as N}from"./BZvTGrCn.js";import{m as w,e as y}from"./DvdFYW7d.js";function b(a){return Math.trunc(a*P)}const T={default:{lifetime:3e3,capacity:3},exporter:{lifetime:1/0,capacity:1/0},protocolcreator:{lifetime:1/0,capacity:1/0}};class g{#t=f();get pools(){return h(this.#t)}set pools(t){d(this.#t,t,!0)}#e=f();get currentPoolName(){return h(this.#e)}set currentPoolName(t){d(this.#e,t,!0)}constructor(t,e){this.currentPoolName=e,this.pools=w(t,i=>({items:[],...i}))}get pool(){return this.pools[this.currentPoolName]}setCurrentPool(t){this.#i(t),this.freeze(this.currentPoolName),this.currentPoolName=t,this.unfreeze(this.currentPoolName)}items(t=void 0){return t&&this.#i(t),this.pools[t??this.currentPoolName].items}#i(t){if(!this.pools[t])throw new Error(`Toast pool ${t} does not exist`)}add(t,e,i){if(!e)return;const{labels:o,data:n,closed:s,action:r,lifetime:c="inferred",...p}=i??{},u={closed:s,action:r};if(Object.values(u).some(Boolean)&&!n)throw new Error("You must provide data if you're using callbacks");const m=N(),l={addedAt:new Date,id:m,message:e.replaceAll(`
`,"; "),type:t,labels:o??{},callbacks:u,data:n??null,lifetime:c==="inferred"?this.#o(e):c,...p};return Number.isFinite(l.lifetime)&&this.#s(l),this.pools[this.currentPoolName].items=[...this.items().slice(0,this.pool.capacity-1),l],m}withUndo(t,e,{undo:i,commit:o,...n}){if(!e)return;const s=this;return this.add(t,e,{lifetime:4*this.#o(e),data:[],...n,closed:o,action:r=>{i(),s.remove(r.id,s.currentPoolName,{silent:!0})},labels:{action:"Annuler"}})}info(t,e){return this.add("info",t,e)}warn(t,e){return this.add("warning",t,e)}error(t,e){return this.add("error",t?.toString()??"Erreur inattendue",{...e,lifetime:e?.lifetime??"inferred"})}success(t,e){return this.add("success",t,e)}async remove(t,e,{silent:i=!1}={}){for(const[o,{items:n}]of y(this.pools)){if(e&&e!==o)continue;const s=n.find(r=>r.id===t);if(!s)return;i||await s.callbacks.closed?.(s),this.pools[o].items=this.items(o).filter(r=>r.id!==t)}}async clear(t=this.currentPoolName){const e=this.items(t);await Promise.all(e.map(i=>i.callbacks?.closed?i.callbacks.closed(i):Promise.resolve())),this.pools[t].items=[]}freeze(t=this.currentPoolName){for(const e of this.items(t).filter(i=>i.timeoutHandle))clearTimeout(e.timeoutHandle)}unfreeze(t=this.currentPoolName){for(const e of this.items(t).filter(i=>i.timeoutHandle))this.#s(e)}#s(t){t.timeoutHandle=setTimeout(()=>{this.remove(t.id)},t.lifetime)}#o(t){const e=t.split(" ").length+t.split(" ").length;return this.pool.lifetime+b(e/300)}}const z=new g(T,"default");export{z as t};
