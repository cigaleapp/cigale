import{aC as u,g as f,aD as h}from"./DLg_PPZ_.js";import{m as N,n as w}from"./BCT7fajR.js";import{m as b,e as T}from"./Csf0LG85.js";function g(a){return Math.trunc(a*N)}const y={default:{lifetime:3e3,capacity:3},exporter:{lifetime:1/0,capacity:1/0}};class k{#t=u();get pools(){return f(this.#t)}set pools(t){h(this.#t,t,!0)}#e=u();get currentPoolName(){return f(this.#e)}set currentPoolName(t){h(this.#e,t,!0)}constructor(t,e){this.currentPoolName=e,this.pools=b(t,s=>({items:[],...s}))}get pool(){return this.pools[this.currentPoolName]}setCurrentPool(t){this.#s(t),this.freeze(this.currentPoolName),this.currentPoolName=t,this.unfreeze(this.currentPoolName)}items(t=void 0){return t&&this.#s(t),this.pools[t??this.currentPoolName].items}#s(t){if(!this.pools[t])throw new Error(`Toast pool ${t} does not exist`)}add(t,e,s){if(!e)return;const{labels:r,data:i,closed:o,action:d,lifetime:l="inferred",...p}=s??{},c={closed:o,action:d};if(Object.values(c).some(Boolean)&&!i)throw new Error("You must provide data if you're using callbacks");const m=w(),P=e.split(" ").length+e.split(" ").length,n={addedAt:new Date,id:m,message:e.replaceAll(`
`,"; "),type:t,labels:r??{},callbacks:c,data:i??null,lifetime:l==="inferred"?this.pool.lifetime+g(P/300):l,...p};return Number.isFinite(n.lifetime)&&this.#i(n),this.pools[this.currentPoolName].items=[...this.items().slice(0,this.pool.capacity-1),n],m}info(t,e){return this.add("info",t,e)}warn(t,e){return this.add("warning",t,e)}error(t,e){return this.add("error",t?.toString()??"Erreur inattendue",{...e,lifetime:e?.lifetime??"inferred"})}success(t,e){return this.add("success",t,e)}async remove(t,e){for(const[s,{items:r}]of T(this.pools)){if(e&&e!==s)continue;const i=r.find(o=>o.id===t);if(!i)return;i.callbacks?.closed&&await i.callbacks.closed(i),this.pools[s].items=this.items(s).filter(o=>o.id!==t)}}async clear(t=this.currentPoolName){const e=this.items(t);await Promise.all(e.map(s=>s.callbacks?.closed?s.callbacks.closed(s):Promise.resolve())),this.pools[t].items=[]}freeze(t=this.currentPoolName){for(const e of this.items(t).filter(s=>s.timeoutHandle))clearTimeout(e.timeoutHandle)}unfreeze(t=this.currentPoolName){for(const e of this.items(t).filter(s=>s.timeoutHandle))this.#i(e)}#i(t){t.timeoutHandle=setTimeout(()=>{this.remove(t.id)},t.lifetime)}}const O=new k(y,"default");export{O as t};
