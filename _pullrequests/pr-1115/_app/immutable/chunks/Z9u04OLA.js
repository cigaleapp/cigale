import{o as b,g,a as v,t as c}from"./h9n_zjAt.js";import{i as I,d as O}from"./CXutPItK.js";import{n as f,m as p,c as S}from"./C0SiBqD8.js";import{m as h}from"./DwQPgNTU.js";import{s as j}from"./BHxAX_Yx.js";import{u as l}from"./fpNj8U5y.js";async function M(t){const a=l.currentProtocol;if(!a)throw new Error("No protocol selected");const o=l.currentSession?.id;if(!o)throw new Error("No session selected");const i=t.map(e=>c.Observation.getFromState(e)).filter(f),n=await Promise.all(t.map(async e=>c.Image.raw.get(e))).then(e=>e.filter(f)),d=new Set(i.flatMap(e=>e.images)).union(new Set(n.map(e=>e.id))),r=g("Observation"),s={id:r,sessionId:o,images:[...d].toSorted(S(e=>t.indexOf(e))),addedAt:new Date().toISOString(),label:m([...i,...n]),metadataOverrides:p(h({definitions:c.Metadata.state,images:[],observations:i}),j)};return s.label=u({protocol:a,images:n,observation:s}),await c.Observation.do(e=>{e.add(s);for(const{id:w}of i)e.delete(w)}),r}async function P(t,{recursive:a=!1,notFoundOk:o=!0,tx:i=void 0}={}){await b(["Observation","Image","ImageFile","ImagePreviewFile"],{},async n=>{const d=await n.objectStore("Observation").get(t);if(!d){if(o)return;throw"Observation non trouvÃ©e"}n.objectStore("Observation").delete(t);const r=await n.objectStore("Image").getAll().then(s=>s.filter(e=>d.images.includes(e.id)));if(a)for(const s of I(r))await O(s,n,o);l.erroredImages.delete(t)})}function u({images:t,observation:a,protocol:o}){return o?.observations?.defaultLabel?.render({images:t,observation:a})||m([a,...t])}function m(t){for(const o of t){if("label"in o)return o.label;if("filename"in o)return o.filename.replace(/\.[^.]+$/,"")}return v("js")(442)}function y(t,a,o){const n={id:g("Observation"),sessionId:o.id,images:[t.id],addedAt:new Date().toISOString(),label:m([t]),metadataOverrides:{}};return{...n,label:u({images:[t],observation:n,protocol:a})}}async function D(t){const a=l.currentSession,o=l.currentProtocol;if(!o)throw new Error("No protocol selected");if(!a)throw new Error("No session selected");await b(["Observation","Image"],{},async i=>{const n=await i.objectStore("Image").index("sessionId").getAll(a.id),d=await i.objectStore("Observation").index("sessionId").getAll(a.id);for(const r of n)if(!d.some(s=>s.images.includes(r.id))){const s=y(r,o,a);i.objectStore("Observation").add(s),l.setSelection?.(l.selection.map(e=>e===r.id?s.id:e))}})}export{P as d,D as e,M as m,y as n};
