import"./h9n_zjAt.js";import{m as b,a as d,n as g}from"./C0SiBqD8.js";import{s as l}from"./CpDocbkH.js";const S=new Set(["boolean","integer","float","date","location","boundingbox","enum"]);function A({definitions:a,images:o,observations:m}){const r=f(o.map(n=>n.metadata),{definitions:a}),t=f(m.map(n=>n.metadataOverrides),{definitions:a}),e=new Set([...Object.keys(r),...Object.keys(t)]),c={};for(const n of e){const s=t[n]??r[n];s&&(c[n]=s)}return c}function f(a,{definitions:o,options:m={}}){if(a.length===1)return b(a[0],e=>({...e,merged:!1}));const r={},t=new Set(a.flatMap(e=>Object.keys(e)));for(const e of t){const c=o.find(i=>i.id===e);if(!c){console.warn(`Cannot merge metadata values for unknown key ${e}`);continue}const n=a.flatMap(i=>Object.entries(i).filter(([u])=>u===e).map(([,u])=>u)),s=w(c,n,m[e]??[]);s!=null&&(r[e]={...s,merged:new Set(n.map(i=>JSON.stringify(i.value))).size>1})}return r}function w(a,o,m=[]){const r=(e,c)=>Object.fromEntries(c.flatMap(n=>Object.keys(n.alternatives)).map(n=>[n,e(c.flatMap(s=>s.alternatives[n]??null).filter(Boolean))])),t=({value:e,confidences:c})=>({value:e,manuallyModified:o.some(n=>n.manuallyModified),confidence:c(o.map(n=>n.confidence)),alternatives:r(c,o)});switch(a.mergeMethod){case"average":return t({confidences:d,value:p({aggregate:d,type:a.type,values:o.map(e=>e.value),options:m})});case"max":case"min":return t({confidences:h,value:x(a.type,o,a.mergeMethod==="max"?h:O)});case"median":return t({confidences:M,value:p({aggregate:M,type:a.type,values:o.map(e=>e.value),options:m})});case"union":return t({confidences:d,value:k(a.type,o.map(e=>e.value))});case"none":return null}}function x(a,o,m){const r=Math.max(...o.map(e=>e.confidence)),t=o.filter(e=>e.confidence===r);try{return m(t.map(e=>e.value))}catch(e){return console.error(e),t[0].value}}function p({type:a,values:o,options:m,aggregate:r}){return l(a,o,{boolean:(...t)=>r(y("boolean",t))>.5,integer:(...t)=>Math.ceil(r(t)),float:(...t)=>r(t),date:(...t)=>new Date(r(y("date",t))),location:(...t)=>({latitude:r(t.map(e=>e.latitude)),longitude:r(t.map(e=>e.longitude))}),enum:(...t)=>{const e=Math.round(r(t.map(c=>m.find(n=>n.key===c)?.index).filter(g)));return m.find(c=>c.index===e)?.key??t[0]}},()=>{throw new Error(`Impossible de fusionner des valeurs de type ${a}`)})}function k(a,o){return l(a,o,{boundingbox:(...m)=>{const r=Math.min(...m.map(n=>n.x)),t=Math.min(...m.map(n=>n.y)),e=Math.max(...m.map(n=>n.x+n.w)),c=Math.max(...m.map(n=>n.y+n.h));return{x:r,y:t,w:e-r,h:c-t}}},()=>{throw new Error(`Impossible de fusionner des valeurs de type ${a} par union`)})}function y(a,o){return o.map(m=>l(a,m,{integer:r=>r,float:r=>r,boolean:r=>r?1:0,date:r=>new Date(r).getTime()},()=>{throw new Error(`Impossible de convertir des valeurs de type ${a} en nombre`)}))}function M(a){const o=a.sort((r,t)=>r-t),m=Math.floor(o.length/2);return o.length%2===0?(o[m-1]+o[m])/2:o[m]}function h(a){return Math.max(...a)}function O(a){return Math.min(...a)}export{S as M,f as a,A as m};
