import { strToU8, zip } from 'fflate';
import { Jimp } from 'jimp';
import { TARGETHEIGHT, TARGETWIDTH } from '../routes/inference/inference';
import * as db from './idb.svelte';
import { imageIdToFileId } from './images';
import { observationMetadata } from './metadata';
/**
 * @param {Array<import("./database").Observation>} observations
 * @param {import('./database').Protocol} protocolUsed
 */
export async function generateResultsZip(observations, protocolUsed) {
	const finalMetadata = Object.fromEntries(
		await Promise.all(
			observations.map(async (o) => [
				o.id,
				{
					label: o.label,
					metadata: await observationMetadata(o)
				}
			])
		)
	);
	const speciesDefinition = await db.tables.Metadata.get('species');
	if (!speciesDefinition) throw 'Species metadata not found';

	/** @param {string} key  */
	const speciesDisplayName = (key) =>
		key ? (speciesDefinition.options?.find((o) => o.key === key)?.label ?? key) : undefined;

	const buffersOfImages = await Promise.all(
		observations.flatMap((o) =>
			o.images.map(async (imageId) => {
				const image = await db.tables.Image.get(imageId);
				if (!image) throw 'Image non trouvée';
				const { contentType, filename } = image;
				const bytes = await cropImage(image);
				return { imageId, bytes: new Uint8Array(bytes), contentType, filename };
			})
		)
	);

	/**
	 * @type {Uint8Array<ArrayBufferLike>}
	 */
	const zipfile = await new Promise((resolve, reject) =>
		zip(
			{
				'analysis.json': strToU8(
					JSON.stringify({
						observations: finalMetadata,
						protocol: protocolUsed
					})
				),
				...Object.fromEntries(
					Object.entries(
						Object.groupBy(
							observations,
							(o) => speciesDisplayName(finalMetadata[o.id].metadata.species) ?? '(Unknown)'
						)
					).map(([species, observations]) => [
						species,
						Object.fromEntries(
							(observations ?? []).map((o) => [
								o.label,
								Object.fromEntries(
									o.images.map((imageId) => {
										const img = buffersOfImages.find((i) => i.imageId === imageId);
										if (!img) throw 'Image non trouvée';
										return [img.filename, [img.bytes, { level: 0 }]];
									})
								)
							])
						)
					])
				)
			},
			{
				comment: `Generated by C.i.g.a.l.e on ${new Date().toISOString()} - ${window.location.origin}`
			},
			(err, data) => {
				if (err) reject(err);
				resolve(data);
			}
		)
	);

	const blob = new Blob([zipfile], { type: 'application/zip' });
	const url = URL.createObjectURL(blob);
	const a = document.createElement('a');
	a.href = url;
	a.download = 'results.zip';
	a.click();
	URL.revokeObjectURL(url);
}

/**
 * @param {import('./database').Image} image
 */
export async function cropImage(image) {
	const boundingBox =
		/** @type {undefined | import("./metadata").RuntimeValue<'boundingbox'>}  */
		(image.metadata.crop?.value);

	if (!boundingBox) throw "L'image n'a pas d'information de recadrage";

	const bytes = await db.get('ImageFile', imageIdToFileId(image.id)).then((f) => f?.bytes);
	if (!bytes) throw "L'image n'a pas de fichier associé";

	const tensor = await Jimp.read(bytes);

	// Inferred crop box is for the [TARGETHEIGHT, TARGETWIDTH] resized image. Scale it back to it fits to the original image.
	const scaleFactors = {
		widthWise: tensor.width / TARGETWIDTH,
		heightWise: tensor.height / TARGETHEIGHT
	};

	const cropped = tensor.crop({
		x: boundingBox.x * scaleFactors.widthWise,
		y: boundingBox.y * scaleFactors.heightWise,
		w: boundingBox.width * scaleFactors.widthWise,
		h: boundingBox.height * scaleFactors.heightWise
	});

	// @ts-ignore
	return cropped.getBuffer(image.contentType);
}
