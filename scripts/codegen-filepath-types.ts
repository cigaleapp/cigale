import path from 'node:path';
import { Glob } from 'bun';

const projectRoot = path.join(import.meta.dir, '..');

const gitignore = await Bun.file(path.join(projectRoot, '.gitignore')).text();

function isGitignored(filepath: string): boolean {
	const rooted = path.relative(projectRoot, filepath).replaceAll('\\', '/');
	return gitignore.split('\n').some((line) => {
		if (line === '') return false;
		if (line.endsWith('/')) {
			return rooted.startsWith(line);
		} else {
			return rooted === line;
		}
	});
}

async function filepathTypeExpression(root: string, glob: string): Promise<string> {
	return await Array.fromAsync(new Glob(glob).scan({ cwd: root })).then((paths) =>
		paths
			.filter((file) => !isGitignored(path.join(root, file)))
			.map((file) => `'${file.replaceAll('\\', '/')}'`)
			.join(' | ')
	);
}

async function filepathTypesDeclarations(
	root: string,
	decls: Record<string, string>
): Promise<string[]> {
	return await Promise.all(
		Object.entries(decls).map(
			async ([typeName, glob]) =>
				`export type ${typeName} = ${await filepathTypeExpression(root, glob)};`
		)
	);
}

async function namespacedDeclarations(
	namespace: string,
	root: string,
	decls: Record<string, string>
): Promise<string[]> {
	return [
		`export namespace ${namespace} {`,
		`export const root = "${root.replaceAll('\\', '/')}";`,
		...(await filepathTypesDeclarations(root, decls)),
		'};'
	];
}

Bun.file(path.join(projectRoot, 'tests', 'filepaths.ts')).write(
	[
		'// This file is autogenerated by scripts/codegen-filepath-type.ts',
		...(await namespacedDeclarations('FixturePaths', 'tests/fixtures', {
			Exports: 'exports/*.zip',
			DatabaseDumps: 'db/*.devalue',
			Photos: '*.{jpeg,jpg,png,cr2}'
		})),
		'',
		...(await namespacedDeclarations('ExamplePaths', 'examples', {
			Protocols: '*.{json,yaml}'
		}))
	].join('\n')
);
